
# 基本类型约束

> TS是一个可选的静态的类型系统

## 如何进行类型约束

仅需要在变量、函数的参数，函数的返回值位置加上```:类型```

简单的例子：

```
function sum1(a:number , b:number) : number{
    return a + b;
}
const total: number = sum1(1,2);
```

- 在js中sum函数可以被更改，如改成```sum = 1```，而在ts中，更改```sum```会报错，```sum(1, 2)```明确知道引用的哪一个函数，则当x选中```sum```使用后F2改变```sum```的函数名字时为```add```时，```sum(1, 2)```也会自动变成```add(1, 2)```
- 自动推导，对于```sum```函数，当指定两个参数为```number```类型时，会自动推导出函数类型为num。ts在很多场景中可以完成类型推导
-  如何知道是否可以推导出类型
    
any：表示任意类型，ts不进行类型检查

> 小技巧：如何区分数字字符串和数字，关键看怎么读？
如果按照数字的方式读，则为数字，否则为字符串。

## 源代码和编译结果的差异

编译结果没有类型约束信息。


## 基本类型

- number: 数字
- string: 字符串
- boolean: 布尔
- number[]: 数组
- object: 对象
- null和undefined

null和undefined可以赋值给其他类型

通过配置文件的```"strictNullChecks": true```可以获得更严格的类型检查,null和undefined只能赋值给自身

## 其他类型

- 联合类型：多种类型各选其一

配合类型保护进行判断

类型保护：当对某个变量进行类型判断后，在判断的语句块中便可以判断它的确切类型，typeof可以触发类型保护。

- void类型：通常用于约束函数返回值，表示该函数没有任何返回值
- never类型：通常用于约束函数返回值，表示该函数永远不会结束
- 字面量类型：使用一个值来约束
- 元组类型：一个固定长度的数组，并且数组中每一项类型确定
- any类型： any类型可以绕过类型检查，因此可以赋值给任意类型（不推荐使用）。

## 类型别名

对一些已知的类型定义名称

```
    type 类型名 = 
```

## 函数的相关约束

函数重载：在函数实现之前，对函数调用的多种情况进行声明.

可选参数：可以在某些参数名后加上?,表示可以选择,可选参数必须在参数末尾。当最后一个参数为默认值且使用时未传递，被认为可选参数。






