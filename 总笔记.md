[toc]

# 在node环境中安装ts环境

## 安装ts环境

默认情况下，ts会做出下面几种假设

1. 假设当前执行环境为dom
2. 如果代码中没有使用模块化（import、export）语句，便认为该代码是全局执行
3. 编译的目标代码是ES3

有两种方式更改以上假设

1. 使用命令行的时候，加上选项
2. 使用ts配置文件，更改配置选项


## ts的配置文件

1. 新建tsconfig.json文件
2. 命令行 tsc --init

使用了配置文件后，使用tsc进行编译时，不能跟上文件名。如果跟上文件名，就将会忽略配置文件。

@types/node

@types是一个官方的类型库，其中包含了很多对js的类型描述。


## 使用第三方库简化流程

ts-node + nodemon



# 基本类型约束

> TS是一个可选的静态的类型系统

## 如何进行类型约束

仅需要在变量、函数的参数，函数的返回值位置加上```:类型```

ts在很多场景中可以完成类型推导

any：表示任意类型，ts不进行类型检查

> 小技巧：如何区分数字字符串和数字，关键看怎么读？
如果按照数字的方式读，则为数字，否则为字符串。

## 源代码和编译结果的差异

编译结果没有类型约束信息。


## 基本类型

- number: 数字
- string: 字符串
- boolean: 布尔
- number[]: 数组
- object: 对象
- null和undefined

null和undefined可以赋值给其他类型

通过配置文件的```"strictNullChecks": true```可以获得更严格的类型检查,null和undefined只能赋值给自身

## 其他类型

- 联合类型：多种类型各选其一

配合类型保护进行判断

类型保护：当对某个变量进行类型判断后，在判断的语句块中便可以判断它的确切类型，typeof可以触发类型保护。

- void类型：通常用于约束函数返回值，表示该函数没有任何返回值
- never类型：通常用于约束函数返回值，表示该函数永远不会结束
- 字面量类型：使用一个值来约束
- 元组类型：一个固定长度的数组，并且数组中每一项类型确定
- any类型： any类型可以绕过类型检查，因此可以赋值给任意类型（不推荐使用）。

## 类型别名

对一些已知的类型定义名称

```
    type 类型名 = 
```

## 函数的相关约束

函数重载：在函数实现之前，对函数调用的多种情况进行声明.

可选参数：可以在某些参数名后加上?,表示可以选择,可选参数必须在参数末尾。当最后一个参数为默认值且使用时未传递，被认为可选参数。

---
theme: juejin
highlight: vs2015
---

 
# 扩展类型 - 枚举

> 扩展类型：类型别名、枚举、接口、类

枚举通常用于约束某个变量的取值范围。

字面量和联合类型配合使用，也可以达到同样的目标。


## 字面量类型的问题

- 在类型约束位置，会产生重复代码。可以使用类型别名解决该问题。

    ```ts
        type Gender = '男' | '女';
        let gender: Gender;
        gender = '男';
        gender = '女';
        function searchUser(g: Gender) {}
    ```
    使用类型别名后，是可以解决上述问题，当时，当我们要修改```Gender```的取值时，我们要修改```gender```的真实值，当代码很多的时候，会显得很繁琐。

- 逻辑含义和真实的值产生了混淆，会导致修改真实值的时候，产生大量的修改。
    
    那么什么是逻辑含义和真实值呢。逻辑含义的意思是```男```和```女```本身，它的真实值可以是```男士```和```女士```，也可以是```帅哥```和```美女```，但逻辑含义是不会变化的。
   因为可能遇到修改真实值的情况，使用字面量类型不是最优选择，因而会有枚举这种方式。
   
    ```ts
        enum Gender {
            male = '男',
            female = '女'
        }
        let gender: Gender;
        gender = Gender.male;
        gender = Gender.female;
        function searchUser(g: Gender) {}
    ```
- 字面量类型不会进入编译结果。
    
    使用字面量类型的编译结果。
    ```js
        let gender;
        gender = '男';
        gender = '女';
        function searchUser(g) { }
    ```
    使用枚举的编译结果。
    ```js
        var Gender;
        (function (Gender) {
            Gender["male"] = "\u7537";
            Gender["female"] = "\u5973";
        })(Gender || (Gender = {}));
        let gender;
        gender = Gender.male;
        gender = Gender.female;
        function searchUser(g) { }
    ```
    使用枚举的编译结果中增加了一个立即执行函数，参数是```Gender```。这意味着枚举是参与到函数运行中的，并且是作为一个对象。基于此，在ts代码中就可以输出```Gender```的属性值。

## 枚举

如何定义一个枚举

```
enum 枚举名 {
    枚举字段1 = 值1,
    枚举字段2 = 值2
}

```

枚举会出现到编译结果中。

枚举的规则：
- 枚举的字段值可以是字符串或数字
  数字枚举的值会自动自增，默认为1，默认依次递增，也可以用相应的规则，如1，2，4，8
- 被数字枚举约束的变量，可以直接赋值为数字(最好不用，尽量使用逻辑名称)。  
- 数字枚举的编译结果 和 字符串枚举有差异
    ```ts
        enum Level {
            level1 = 1,  
            level2 = 2,
            level3 = 3
        }
        let l: Level;
        l = Level.level1;
        console.log(l);
        console.log(Level)
    ```
    
    编译结果
    
    ```ts
        var Level;
        (function (Level) {
            Level[Level["level1"] = 1] = "level1";
            Level[Level["level2"] = 2] = "level2";
            Level[Level["level3"] = 3] = "level3";
        })(Level || (Level = {}));
        let l;
        l = Level.level1;
        console.log(l);
        console.log(Level)
    ```
    
    如果是数字枚举，编译结果输出的Level是
    
    ```js
         {
              '1': 'level1',
              '2': 'level2',
              '3': 'level3',
              level1: 1,
              level2: 2,
              level3: 3
         }
    ```
    如果是字符串类型，则为
    ```js
          { level1: '1', level2: '2', level3: '3' }
    ```

最佳实践
- 尽量不要在一个枚举中既出现字符串字段，又出现数字字段。
- 使用枚举时，尽量使用枚举字段的名称，而不是真实的值

[使用枚举完善打印扑克牌例子github](https://github.com/Lusaiwen/TypeScript/tree/3.%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B---%E6%9E%9A%E4%B8%BE)






前端模块化标准：ES6、commonJS、amd、umd、system、esnext

# 模块化

相关配置

|       配置名称        |           含义                |
| :-------------------: | :-------------------------: |
|        module         | 设置编译结果中使用的模块化标准 |
|    moduleResolution  | 设置解析模块的模式 |
|  noImplicitUserStrict | 编译结果中不包含"use strict"|
|  removeComments | 编译结果移除注释 |
|  noEmitOnError | 错误时不生成编译结果 |
|  esModuleInterop | 启用es模块交互 |

本文主要解决两个问题

> TS中如何书写模块化语句

> 编译结果

## TS中如何让书写模块化语句

TS中，导入和导出模块，统一使用ES6的模块化标准。

简单例子

```ts
    export function sum(a: number, b: number) {
        return a + b;
    }
    export const a: number = 1;
    export default function getTime() {
        console.log(Date.now());
    }
```
```ts
    import getTime, { sum, a } from './myModule';
    console.log(sum(1, 2));
    console.log(a);
    console.log(getTime());
```

和我们正常书写ES6模块化代码一样，有几个需要注意的点

- 模块化文件不要使用默认导出，默认导出不能享受到TS的模块导入智能提示。
- 引入模块化文件时，不要加后缀名```.ts```，会报错，编译结果中不存在ts文件。


## 编译结果中的模块化

可以在配置文件中进行配置模块化标准 

TS中的模块化在编译结果中：

- 如果编译结果的模块化标准是ES6：没有区别
    
    配置文件中模块化配置为：```"module": "ES6"```，编译结果和ts代码相同
    ```js
        //模块化文件
        export function sum(a, b) {
            return a + b;
        }
        export const a = 1;
        export default function getTime() {
            console.log(Date.now());
        }

        //引用模块化文件
        import getTime, { sum, a } from './myModule';
        console.log(sum(1, 2));
        console.log(a);
        console.log(getTime());
    ```
- 如果编译结果中的模块化标准是commomjs：导出的声明会变成exports的属性，默认的导出会变成exports的default属性。

    配置文件中模块化配置为：```"module": "CommonJS"```，编译结果
     ```js
        //模块化文件
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.a = exports.sum = void 0;
        function sum(a, b) {
            return a + b;
        }
        exports.sum = sum;
        exports.a = 1;
        function getTime() {
            console.log(Date.now());
        }
        exports.default = getTime;

        
        //引用模块化文件
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const myModule_1 = require("./myModule");
        console.log((0, myModule_1.sum)(1, 2));
        console.log(myModule_1.a);
        console.log((0, myModule_1.default)());
    ```
    
    可以使用```"noImplicitUseStrict": false```去掉编译结果中的```"use strict"```，ts本身就很严格了。
    
    很奇怪的是，模块化文件编译结果中的```void 0```和``` console.log((0, myModule_1.sum)(1, 2))```
    
    ```void```是一元表达式，void 运算符对给定的表达式进行求值，然后返回undefined
    
    ```
        void 0 === void（0） === undefined
    ```
    
    为什么这样写，简单来说就是```undefined```是全局对象window的属性，低版本浏览器中可以被修改
    
    逗号运算符是二元运算符，它能够先执行运算符左侧的操作数，然后再执行右侧的操作数，最后返回右侧操作数的值,``` console.log((0, myModule_1.sum)(1, 2))```实际上就是```console.log(myModule_1.sum)(1, 2))```


## 解决默认导入的错误 

在ts中想要使用```fs```模块，正常写法应该是这样

```ts
    import fs from 'fs';   //报错，fs没有默认导出
    fs.readFileSync('./');
```

```fs```模块是```module.exports  = {}```导出的，前面的例子说明ts中使用ES6默认导出，编辑结果中是```exports.default```，所以导致报错 

解决办法

- 使用```import { readFileSync } from 'fs';```
- 使用```import * as fs from 'fs';```
- 配置参数```"esModuleInterop": true```
    
    引用模块的编译结果为
    
    ```js
        var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
        }; 
        Object.defineProperty(exports, "__esModule", { value: true });
        const fs_1 = __importDefault(require("fs"));
        fs_1.default.readFileSync('./');
    ```
  
  
## 如何在typescript中书写CommonJS（不建议使用）

导出：```export = xxx```，才会具有类型检查，会有智能提示

导入：```import xxx = require("xxx")```或```import xxx from "xxx"```

不建议使用commonJS模块化代码，除非有不可描述的原因。


## 模块解析

模块解析：应该从什么位置寻找模块

TS中，有两种模块解析策略

- classic：经典（老版本）
- node：node解析策略（唯一的变化，是将js替换为ts）
    - 相对路径```require("./xxx")```

         先找当前目录有没有该文件，如果没有，再找package.json文件中是否配置```"main": "xxx"```，如果有则在当前目录下找该文件，如果没有，则找当前目录下有有没有index.ts文件

        
    - 非相对路径```require("xxx")```

        在当前目录找```node_modules```目录，没有则继续在上级找，直到找到



## 练习

[模块化实现扑克牌例子github](https://github.com/Lusaiwen/TypeScript/tree/4.%E6%A8%A1%E5%9D%97%E5%8C%96)




# 接口和类型兼容性

接口： interface

## 扩展类型 - 接口

> 扩展类型: 类型别名、枚举、接口、类

TypeScript的接口：用于约束类、对象、函数的契约（标准）

类似于电脑的接口或后端接口，其实就是一种标准

契约（标准）的形式：
- API文档（弱标准）
- 代码约束（强标准）

和类型别名一样，不会出现在编译结果中，和类型别名区别主要在类这一块

1. 接口约束对象

```ts
    interface User {
      name: string
      age: number
      sayHello: () => void
      //sayHello(): void
    }
    let u: User = {
      name: "saiwen",
      age: 22,
      sayHello() {
        console.log("sayHello");
      }
    };
```
这不就是跟类型别名一样吗？个人建议使用接口约束对象。

2. 接口约束函数

一个简单例子，数组中奇数相加之和
```ts
    interface Condition {
      (n: number): boolean
    }
    function sum(numbers: number[], callback: Condition): number {
      let sum = 0;
      numbers.forEach((n) => {
        if (callback(n)) {
          sum += n;
        }
      });
      return sum;
    }
    const result = sum([1, 3, 4, 5, 7], (n) => n % 2 !== 0);
    console.log(result)
```

对函数的约束也可以使用类型别名

```ts
    type Condition = (n: number) => boolean
```

**接口可以继承**


可以通过接口之间的继承，实现多种接口的组合。

```ts
    interface A {
        T1: string
    }
    interface B {
        T2: number
    }
    interface C extends A, B {
        T3: boolean
    }
    let u: C = {
        T1: '1',
        T2: 1,
        T3: true
    }
```

使用类型别名也可以实现继承，需要使用```&```，叫做交叉类型

```ts
    type C {
        T3: boolean
    } & A & B
```

区别是子接口不能够覆盖父接口成员，会报错，而交叉类型会对子类型中同名变量的类型进行合并，如
```ts
    type C {
        T1: number
        T3: boolean
    } & A & B
    let u: C = {
        T1: '1',  //T1类型为string和number，报错，会提示两种类型所有方法
        T2: 1,
        T3: true
    }
```


**readonly**

只读修饰符，修饰的目标是只读，不在编译结果中

```ts
interface User {
    readonly id: string
}
```
只能够赋初始值，后面不能更改

```ts
let arr: readonly number[] = [1, 2, 3];
arr = [2, 3, 4]
```

此时```readonly```修饰的是类型，此时数组的```push``` ```pop```等方法无效，而```arr```是可以改变的 
```ts
interface User {
    readonly arr: string []
}
let u：User = {
    arr: ['s', 't']
}
u.arr.push('t');
//u.arr = ['t'];//报错
```
这种写法中，```readonly```修饰的是数组，不是类型，数组的地址是不能改变的。修饰对象中的属性只能用```readonly```，其他情况下使用```const```就可以了。
可以修饰数组和修饰类型一起使用，做到数组完全不能变。

## 类型兼容性

TS如何来判定两个类型是否兼容，可以实现互相赋值。

B -> A，如果能完成赋值，则B和A类型兼容。 

TS使用鸭子辨型法（子结构辨别法）：目标类型需要某一些特征，赋值的类型只要能满足某些特征即可。就像鸭子有会嘎嘎叫和会游泳两个特征。

以下是各种类型的规则

- 基本类型：完全匹配
- 对象类型：鸭子辨型法
    ```ts
        interface Duck {
            sound: '嘎嘎'
            swin(): void
        }
        let person = {
            name: '扮演鸭子',
            sound: '嘎嘎嘎' as '嘎嘎嘎',  //类型断言
            swim(){
                console.log('游泳')
            }
        }
        let duck: Duck = person; //可以赋值
    ```
    
    对象进行赋值时，只要符合某些特征就可以进行赋值
    
    ** 特殊情况**
       直接使用字面量类型会报错，这本身也符合对Duck的类型约束
    ```ts
        let duck: Duck = {
            name: '扮演鸭子',
            sound: '嘎嘎嘎' as '嘎嘎嘎',  //类型断言
            swim(){
                console.log('游泳')
            }
        }; 
    ```
    只要右边是对象变量形式，都使用鸭子辨型法。
    TS认为直接对```duck```赋值时，认为开发者明确知道自己在做什么，使用更严格的判断，而使用对象进行赋值时，该对象可能来源于一个函数，类型约束变的宽松，比如一个后端接口 ，我们需要使用其中个别属性，后端不可能还要分成两个对象来传。
    
- 函数类型：一切无比自然


```ts
    interface Condition {
      (n: number): boolean
    }
    function sum(numbers: number[], callback: Condition): number {
      let sum = 0;
      numbers.forEach((n, i) => {
        if (callback(n, i)) {
          sum += n;
        }
      });
      return sum;
    }
    const result = sum([1, 3, 4, 5, 7], (n) => n % 2 !== 0);
    console.log(result)
```

**参数**：传递给目标函数的参数可以少，但不可以多

**返回结果**：要求返回时必须返回。类型要正确，不要求返回时随便，即使返回了也不会用到

    
    
    
    
    
    
    










 














