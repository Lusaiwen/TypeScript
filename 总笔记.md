[toc]

# 在node环境中安装ts环境

## 安装ts环境

默认情况下，ts会做出下面几种假设

1. 假设当前执行环境为dom
2. 如果代码中没有使用模块化（import、export）语句，便认为该代码是全局执行
3. 编译的目标代码是ES3

有两种方式更改以上假设

1. 使用命令行的时候，加上选项
2. 使用ts配置文件，更改配置选项


## ts的配置文件

1. 新建tsconfig.json文件
2. 命令行 tsc --init

使用了配置文件后，使用tsc进行编译时，不能跟上文件名。如果跟上文件名，就将会忽略配置文件。

@types/node

@types是一个官方的类型库，其中包含了很多对js的类型描述。


## 使用第三方库简化流程

ts-node + nodemon



# 基本类型约束

> TS是一个可选的静态的类型系统

## 如何进行类型约束

仅需要在变量、函数的参数，函数的返回值位置加上```:类型```

ts在很多场景中可以完成类型推导

any：表示任意类型，ts不进行类型检查

> 小技巧：如何区分数字字符串和数字，关键看怎么读？
如果按照数字的方式读，则为数字，否则为字符串。

## 源代码和编译结果的差异

编译结果没有类型约束信息。


## 基本类型

- number: 数字
- string: 字符串
- boolean: 布尔
- number[]: 数组
- object: 对象
- null和undefined

null和undefined可以赋值给其他类型

通过配置文件的```"strictNullChecks": true```可以获得更严格的类型检查,null和undefined只能赋值给自身

## 其他类型

- 联合类型：多种类型各选其一

配合类型保护进行判断

类型保护：当对某个变量进行类型判断后，在判断的语句块中便可以判断它的确切类型，typeof可以触发类型保护。

- void类型：通常用于约束函数返回值，表示该函数没有任何返回值
- never类型：通常用于约束函数返回值，表示该函数永远不会结束
- 字面量类型：使用一个值来约束
- 元组类型：一个固定长度的数组，并且数组中每一项类型确定
- any类型： any类型可以绕过类型检查，因此可以赋值给任意类型（不推荐使用）。

## 类型别名

对一些已知的类型定义名称

```
    type 类型名 = 
```

## 函数的相关约束

函数重载：在函数实现之前，对函数调用的多种情况进行声明.

可选参数：可以在某些参数名后加上?,表示可以选择,可选参数必须在参数末尾。当最后一个参数为默认值且使用时未传递，被认为可选参数。


# 模块化

相关配置

|       配置名称        |           含义                |
| :-------------------: | :-------------------------: |
|        module         | 设置编译结果中使用的模块化标准 |
|    moduleResolution  | 设置解析模块的模式 |
|  noImplicitUserStrict | 编译结果中不包含"use strict"|
|  removeComments | 编译结果移除注释 |
|  noEmitOnError | 错误时不生成编译结果 |
|  esModuleInterop | 启用es模块交互 |




> TS中如何书写模块化语句
> 编译结果

## TS中如何让书写模块化语句

TS中，导入和导出模块，统一使用ES6的模块化标准。

## 编译结果中的模块化

可配置

TS中的模块化在编译结果中：

- 如果编译结果的模块化标准是ES6：没有区别
- 如果编译结果中的模块化标准是commomjs：导出的声明会变成exports的属性，默认的导出会变成exports的default属性。

## 如何在typescript中书写CommonJs（不建议使用）

导出：```export = xxx```

导入：```import xxx = require("xxx")```


## 模块解析

模块解析：应该从什么位置寻找模块

TS中，有两种模块解析策略

- classic：经典（老版本）
- node：node解析策略（唯一的变化，是将js替换为ts）
    - 相对路径```require("./xxx")```
    - 非相对路径```require("xxx")```









